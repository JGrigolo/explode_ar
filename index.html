<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Parede que se quebra + Flow Field</title>
  <style>
    body{margin:0;overflow:hidden;}
    .hint{position:fixed;left:8px;top:8px;background:rgba(0,0,0,0.5);color:#fff;padding:8px;border-radius:6px;font-family:sans-serif;font-size:13px;z-index:10}
    #triggerBtn{position:fixed;right:8px;top:8px;padding:10px 15px;font-size:14px;z-index:20;}
  </style>
</head>
<body>
  <div class="hint">Clique no botão para simular o efeito de quebra da parede e mostrar o flow field.</div>
  <button id="triggerBtn">Ativar efeito</button>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <!-- AR.js para A-Frame -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>

  <a-scene embedded vr-mode-ui="enabled: false" renderer="logarithmicDepthBuffer: true" arjs="sourceType: webcam; debugUIEnabled: false;">
    <a-entity id="effects" wall-break></a-entity>
    <a-entity camera look-controls-enabled="false" position="0 0 3"></a-entity>
  </a-scene>

  <script>
    AFRAME.registerComponent('wall-break', {
      init: function () {
        const el = this.el;
        this.boxGroup = new THREE.Group();
        el.object3D.add(this.boxGroup);

        this.particlesGroup = new THREE.Group();
        el.object3D.add(this.particlesGroup);

        this.capturing = false;
        this.flowParticles = [];
        this.particleCount = 800;
        this.clock = new THREE.Clock();
        this.elapsed = 0;

        // parâmetros dos blocos
        this.cols = 16;
        this.rows = 12;
        this.blockSize = 0.25;
        this.breakForce = 1.2;

        // canvas temporário (cor padrão)
        this.captureCanvas = document.createElement('canvas');
        this.captureCtx = this.captureCanvas.getContext('2d');
        this.captureCanvas.width = 640;
        this.captureCanvas.height = 480;
        this.captureCtx.fillStyle = '#888';
        this.captureCtx.fillRect(0,0,640,480);

        document.getElementById('triggerBtn').addEventListener('click', () => this.onTrigger());

        this.animate = this.animate.bind(this);
        requestAnimationFrame(() => {
          // aguarda o AR.js inicializar o sistema antes de acessar a câmera
          const sceneEl = this.el.sceneEl;
          sceneEl.addEventListener('loaded', () => {
            this.camera = sceneEl.camera;
            this.animate();
          });
        });
      },

      flowVector: function(x,y,z,t){
        const vx = Math.sin(x*1.2+t*0.5)+Math.cos(y*1.5-t*0.3);
        const vy = Math.sin(y*1.3+t*0.7)*0.8 + Math.cos(x*0.9+t*0.2)*0.2;
        const vz = Math.cos(z*1.1-t*0.5)+Math.sin((x+y)*0.6+t*0.4);
        const v = new THREE.Vector3(vx,vy,vz);
        v.normalize().multiplyScalar(0.6);
        return v;
      },

      onTrigger: function(){
        if(this.capturing) return;
        this.capturing = true;
        this.createBlocks();
        this.createFlowField();
      },

      createBlocks: function(){
        while(this.boxGroup.children.length) this.boxGroup.remove(this.boxGroup.children[0]);
        const offsetX = -(this.cols*this.blockSize)/2 + this.blockSize/2;
        const offsetY = (this.rows*this.blockSize)/2 - this.blockSize/2;
        for(let y=0;y<this.rows;y++){
          for(let x=0;x<this.cols;x++){
            const geo = new THREE.BoxGeometry(this.blockSize,this.blockSize,this.blockSize);
            const mat = new THREE.MeshStandardMaterial({color:0x888888, roughness:0.9, metalness:0});
            const mesh = new THREE.Mesh(geo,mat);
            mesh.position.set(offsetX+x*this.blockSize, offsetY-y*this.blockSize, 0);
            mesh.userData = {
              vel: new THREE.Vector3((Math.random()-0.5)*this.breakForce,(Math.random()-0.5)*this.breakForce,-Math.random()*this.breakForce*1.5),
              rotVel: new THREE.Vector3(Math.random()*2-1,Math.random()*2-1,Math.random()*2-1),
              life:0,
              maxLife:2+Math.random()*2
            };
            this.boxGroup.add(mesh);
          }
        }
        const hemi = new THREE.HemisphereLight(0xffffff,0x444444,1.2);
        hemi.position.set(0,1,0.5);
        this.boxGroup.add(hemi);
      },

      createFlowField: function(){
        while(this.particlesGroup.children.length) this.particlesGroup.remove(this.particlesGroup.children[0]);
        this.flowParticles = [];
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(this.particleCount*3);
        for(let i=0;i<this.particleCount;i++){
          const x=(Math.random()-0.5)*2.5;
          const y=(Math.random()-0.5)*2.5;
          const z=-5+(Math.random()-0.5);
          positions[i*3]=x; positions[i*3+1]=y; positions[i*3+2]=z;
          this.flowParticles.push({pos:new THREE.Vector3(x,y,z)});
        }
        geometry.setAttribute('position',new THREE.BufferAttribute(positions,3));
        const material = new THREE.PointsMaterial({size:0.04, transparent:true, opacity:0.95, color:0xffaa00});
        const points = new THREE.Points(geometry,material);
        points.frustumCulled=false;
        this.particlesGroup.add(points);
        this.pointsObj = points;
      },

      animate: function(){
        requestAnimationFrame(this.animate);
        const dt = this.clock.getDelta();
        this.elapsed += dt;

        // animação dos blocos
        for(let i=this.boxGroup.children.length-1;i>=0;i--){
          const m=this.boxGroup.children[i];
          if(!m.userData) continue;
          m.userData.life+=dt;
          m.position.addScaledVector(m.userData.vel, dt);
          m.rotation.x+=m.userData.rotVel.x*dt;
          m.rotation.y+=m.userData.rotVel.y*dt;
          m.rotation.z+=m.userData.rotVel.z*dt;
          m.userData.vel.y-=0.9*dt;
          if(m.userData.life>m.userData.maxLife){
            m.material.opacity = Math.max(0,(m.material.opacity||1)-dt*0.6);
            if(m.material.opacity<=0.02) this.boxGroup.remove(m);
          }
        }

        // animação flowfield
        if(this.pointsObj){
          const positions = this.pointsObj.geometry.attributes.position.array;
          for(let i=0;i<this.flowParticles.length;i++){
            const p=this.flowParticles[i];
            const f=this.flowVector(p.pos.x,p.pos.y,p.pos.z,this.elapsed);
            p.pos.addScaledVector(f, dt);
            const towardCenter = new THREE.Vector3().subVectors(new THREE.Vector3(0,0,-5),p.pos).multiplyScalar(0.02);
            p.pos.addScaledVector(towardCenter, dt*12);
            positions[i*3]=p.pos.x; positions[i*3+1]=p.pos.y; positions[i*3+2]=p.pos.z;
          }
          this.pointsObj.geometry.attributes.position.needsUpdate=true;
        }
      }
    });
  </script>
</body>
</html>
